<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../style.css" />
    <script src="../script.js"></script>
    <title>Go</title>
  </head>
  <body>
    <h1><a href="../index.html">Go</a></h1>

    <div class="main">
      <p>
        <a href="https://go.dev/ref/spec" target="_blank">Especification go</a>
        |
        <a href="https://go.dev/doc/effective_go" target="_blank"
          >Effective go</a
        >
        |
        <a href="https://pkg.go.dev/std" target="_blank">Standard library</a>
      </p>

      <div id="div0" onclick='show("div0")'>
        <h4>Preparar workspace</h4>
        <div class="oculto">
          <p>Primeiro é preciso criar a estrutura padrão de pastas.</p>
          <pre>
C:\Users\Andre\go...
            \bin
            \pkg
            \src\github.com\andre\projeto
          </pre>
          <p>
            Na pasta "C:\Users\Andre\go\src\github.com\andre" é onde serão
            criados os projetos, com cada pasta sendo um projeto. Dentro da
            pasta do projeto, cria o arquivo principal main.go e executa o
            comando "go mod init" dentro dessa pasta. Ao criar uma outra pasta
            dentro da pasta raiz, é possível criar um package, criando um
            arquivo ".go" dentro dessa outra pasta, o arquivo ".go" dentro dessa
            pasta poderá ser importado pelo arquivo principal, exemplo:
          </p>
          <pre>
            No package
            C:\Users\Andre\go\src\github.com\andre\pojeto\pkg1\pkg1.go
            package pkg1
            import "fmt"
            func Hello() {
              fmt.Println("Hello world!")
            }
            No arquivo principal
            C:\Users\Andre\go\src\github.com\andre\pojeto\main.go
            package main
            import "github.com\andre\pojeto\pkg1"
            func main() {
              pkg1.Hello()
            }
          </pre>
          <p>
            Depois disso pode rodar o comando "go run main.go". Lembrando que As
            funções e variáveis no package precisam começar com letra maiúscula
            para serem públicas e acessiveis por outros scripts, se forem com
            letra minúscula, serão privadas e acessiveis apenas dentro do
            package. Por convenção, utilize sempre o mesmo nome para a pasta do
            package e o arquivo do package.
          </p>
        </div>
      </div>

      <div id="div1" onclick='show("div1")'>
        <h4>Mostrar / Alterar env</h4>
        <div class="oculto">
          <span>go env</span>
          <p><span>go env -w propriedade=valor</span></p>
        </div>
      </div>

      <div id="div2" onclick='show("div2")'>
        <h4>Criar executável</h4>
        <div class="oculto"><span>go build arquivo.go</span></div>
      </div>

      <div id="div3" onclick='show("div3")'>
        <h4>Ativar get / install</h4>
        <div class="oculto">
          <span>go env -w GO111MODULE=auto</span>
          <span>go env -w GOBIN=C:\Users\Andre\go\bin</span>
        </div>
      </div>

      <div id="div4" onclick='show("div4")'>
        <h4>Ver funções de um package</h4>
        <div class="oculto">
          <p>
            Acesse
            <a href="https://pkg.go.dev/" target="_blank">go packages</a> ao
            achar o package vá em index para ver as funções dele
          </p>
        </div>
      </div>

      <div id="div5" onclick='show("div5")'>
        <h4>Ignorar um retorno de uma função</h4>
        <div class="oculto">
          <p>
            Se uma função retorna dois valores e você só quer usar um, utilize o
            "_" underline no lugar onde receberia o retorno e coloque a variável
            no outro lugar para receber o outro valor
          </p>
        </div>
      </div>

      <div id="div6" onclick='show("div6")'>
        <h4>Manipulando Strings</h4>
        <div class="oculto">
          <p>
            Para utilizar aspas em uma string faça assim: "Ola \"meu amigo\""
          </p>
        </div>
      </div>

      <div id="div7" onclick='show("div7")'>
        <h4>Converter tipos de variáveis</h4>
        <div class="oculto">
          <p><span>x = int(c)</span> Atribui o tipo int à variável c</p>
        </div>
      </div>

      <div id="div8" onclick='show("div8")'>
        <h4>Declarar várias constantes em uma linha</h4>
        <div class="oculto">
          <p>
            Constantes não tem tipos definidos. Só são definidos depois de ser
            utilizada
          </p>
          <span>
            <pre>
            const (
                x = 10
                y=20
                z=30
            )</pre
            >
          </span>
        </div>
      </div>

      <div id="div9" onclick='show("div9")'>
        <h4>Utilizando iota (sequência de números)</h4>
        <div class="oculto">
          <pre><span>const (
                x = iota + 100
                _
                z
              )
          </span></pre>
          <p>
            Neste formato, x será 100, o "_" faz com que pule o próximo valor da
            sequência e o z será 102
          </p>
        </div>
      </div>

      <div id="div10" onclick='show("div10")'>
        <h4>Utilizando "for"</h4>
        <div class="oculto">
          <p>"for" padrão</p>
          <pre><span>for x := 0; x &lt; 5; x++ {
  if x%2 == 0 {			
  fmt.Println(x)  
  } 
          }</span></pre>
          <p>"for" funcionando como "while"</p>
          <pre><span>y := 0
              for {
                fmt.Println(y)
                y++
                if y == 10 {			
                  break 
                }
                }</span></pre>
          <p>
            "for" também pode ser usado apenas com uma clausula. Ex:
            <span>for a > B { }</span>
          </p>
          <p>
            Pode-se usar "continue" para pular para a próxima iteração ignorando
            o restante do código no loop
          </p>
        </div>
      </div>

      <div id="div11" onclick='show("div11")'>
        <h4>Condicionais</h4>
        <div class="oculto">
          <h3>if e else</h3>
          <pre><span>if x > 10 {
            fmt.Println("Ok")
          } else if {
            fmt.Println("Talvez")
          } else {
            fmt.Println("Não")
          }</span></pre>
          <p>Pode-se inverter o resultado da condição com "!"</p>
          <pre><span>if !(x > 10) {
            fmt.Println("Ok")
          }</span></pre>
          <p>É possível declarar o valor de "x" dentro do "if":</p>
          <pre><span>if x := 5; (x > 10) {
            fmt.Println("Ok")
          }</span></pre>
          <h3>switch</h3>
          <pre><span>x := 10
            switch {
            case x &lt; 5:
              fmt.Println("x é menor que 5")
            case x == 5:
              fmt.Println("x é igual a 5")
            case x &gt; 5:
              fmt.Println("x é maior que 5")
            default:
              fmt.Println("Nenhum dos anteriores")
            }</span></pre>
          <p>
            Também é possível um case verificar duas possibilidades separadas
            por vírgula. Se uma das duas for true, vai executar aquele case.
          </p>
        </div>
      </div>

      <div id="div12" onclick='show("div12")'>
        <h4>Arrays</h4>
        <div class="oculto">
          <p>
            Para declarar um array é assim:
            <span>var x [5]int{0, 3, 5, 7, 9}</span>
          </p>
          <p>Isso quer dizer que esse array tem 5 posições, contando com o 0</p>
          <p>
            Para atribuir um valor a um elemento do array é assim:
            <span>x[0] = 1</span> Agora o elemento na posição 0 do array tem o
            valor 1. O restante dos elementos vai ter o valor 0 por padrão se os
            valores não forem definidos
          </p>
          <p>
            Para ler uma posição do array é assim:
            <span>fmt.Printls(x[0])</span> Será mostrado o valor do elemento na
            posição 0
          </p>
          <p>
            Não é possível acrescentar ou retirar elementos do array depois de
            criado
          </p>
        </div>
      </div>

      <div id="div13" onclick='show("div13")'>
        <h4>Slices</h4>
        <div class="oculto">
          <p>Criando um slice: <span>slice := [ ]int{1,2,3,4,5}</span></p>
          <p>
            Alterando valor de elemento do slice: <span>slice[3] = 8</span> O
            elemento na posição 3 passa a ser 8
          </p>
          <p>
            Adiconando elementos ao slice:
            <span>slice = append(slice, 6, 7, 8)</span> Com isso, foi
            acrescentado mais elementos na slice
          </p>
          <p>
            <span>slice = append(slice, slice...)</span> Para adicionar uma
            slice dentro de outra, é preciso colocar os 3 pontos
          </p>
          <p>Percorrendo um slice</p>
          <pre><span>slice := [ ]int{5, 7, 9, 2, 8}
            for indice, valor := range slice {
              fmt.Printf("indice: %v valor: %v\n", indice, valor)
            }</span></pre>
          <p>Pegando elementos do slice</p>
          <p>
            <span>fatia := slice[0:2]</span> Aqui vai pegar os valores do indice
            0 ao 1. O último indice a ser pego tem que acrescentar mais 1
          </p>
          <p>
            <span>fatia := slice[1:]</span> Aqui pega do indice 1 até o final
          </p>
          <p><span>fatia := slice[:4]</span> Aqui pega do indice 0 até o 3</p>
          <p><span>fatia := slice[:]</span> Aqui pega todos</p>
          <p>Remover elementos de um slice</p>
          <p>
            <span>slice = append(slice[:2], slice[3:]...)</span> Aqui vai ser
            atribuído ao slice os elementos do 0 ao 1 e os elementos do 3 ao
            fim, deixando de fora o elemento 2
          </p>
          <span>slice2 := append(slice[:2], slice[3:]...)</span>
          <h2 class="alert">
            ATENÇÃO!!! Não crie um slice fatiando outro slice(como acima), pois
            isso causa perdas de elementos no primeiro slice
          </h2>
        </div>
      </div>

      <div id="div14" onclick='show("div14")'>
        <h4>Mostrar número de elementos em um slice</h4>
        <div class="oculto">
          <span>lista := [ ]int{3,5,2,8}</span>
          <p><span>fmt.Println(len(lista))</span></p>
        </div>
      </div>

      <div id="div15" onclick='show("div15")'>
        <h4>Utilizando make com slices</h4>
        <div class="oculto">
          <p>
            Utilizando make para criar um slice, é definido um limite para a
            capacidade do slice, e se esse limite for ultrapassado, é definido
            um novo limite com o dobro da capacidade. Dessa forma há um ganho em
            desempenho
          </p>
          <p>
            <span>slice := make([]int, 5, 10)</span> O 5 representa a quantidade
            de elementos que já existem no slice e o 10 é o limite de elementos
            que o slice suporta.
          </p>
          <p>
            Para vizualizar a capacidade do slice, usa-se:
            <span>cap(slice)</span>
          </p>
        </div>
      </div>

      <div id="div16" onclick='show("div16")'>
        <h4>Slices multidimensionais(slice dentro de slice)</h4>
        <div class="oculto">
          <pre><span>	slice := [ ][ ]int{
            [ ]int{1, 2, 3, 4},
            [ ]int{10, 20, 30, 40},
          }        
          fmt.Println(slice[1][1])</span></pre>
          <p>
            Neste exemplo será impresso o valor do slice 1 na posição 1, que é
            20
          </p>
        </div>
      </div>

      <div id="div17" onclick='show("div17")'>
        <h4>Utilizando Map(object JS)</h4>
        <div class="oculto">
          <pre><span>agenda := map[string]int{
            "maria": 444567,
            "joao":  222341,
          }
          fmt.Println(agenda["joao"])</span></pre>
          <p>
            Para adicionar outra chave / valor:
            <span>agenda["pedro"] = 666756</span>
          </p>
          <p>
            Para verificar se a chave existe, utliza-se o "comma ok idiom".
            Deve-se declarar duas variáveis que vão receber o map com uma chave,
            se a chave existir, a primeira variável vai receber o valor da chave
            e a segunda variável vai ser true, se não existir, a primeira
            variável vai ser 0 e a segunda false. Exemplo:
          </p>
          <pre><span>if verifica, ok := agenda["marcos"]; ok {
            fmt.Println(verifica)
          } else {
            fmt.Println("Chave não existe!")
          }</span></pre>
          <p>
            Para percorrer um map usa-se o for com range. O range de um map é
            aleatório, não segue a ordem das chaves que estão no map.
          </p>
          <pre><span>for key, value := range agenda {
            fmt.Println(key, value)
          }</span></pre>
          <p>Deletando uma chave <span>delete(agenda, "maria")</span></p>
        </div>
      </div>

      <div id="div18" onclick='show("div18")'>
        <h4>Utilizando Structs</h4>
        <div class="oculto">
          <p>
            Struct serve para armazenar tipos de dados diferentes e funciona
            parecido com um map
          </p>
          <pre><span>type client struct {
            name    string
            surname string
            smoking bool
          }
          
          func main() {
            cliente1 := client{
              name:    "Joana",
              surname: "da Silva",
              smoking: true,
            }
            cliente2 := client{"José", "Soares", false}</span></pre>
          <p>Adicionando um struct dentro de outro</p>
          <pre><span>type profile struct {
            client
            gender  string
            visits  int
            average string
          }
          
          func main() {
            cliente1 := profile{
              client: client{
                name:    "Joana",
                surname: "da Silva",
                smoking: true,
              },
              gender:  "female",
              visits:  24,
              average: "two per week",
            }</span></pre>
          <p>
            Tem ainda o struct anônimo, onde não é definido um type e é criado
            diretamente na variável, porém ele não pode ser alterado nem
            reutilizado
          </p>
          <pre><span>cliente := struct {
            name string
            age  int
          }{
            name: "Joana",
            age:  34,
          }</span></pre>
          <p>
            Acessar chaves de uma struct
            <span>fmt.Println(cliente1.gender, cliente1.client.name)</span>
          </p>
        </div>
      </div>

      <div id="div19" onclick='show("div19")'>
        <h4>Utilizando funções</h4>
        <div class="oculto">
          <pre><span>func main() {
            result, message := sum("bom dia", 2, 4, 5, 6, 7, 10)
            fmt.Println(result, message)
          }
          func sum(msg string, x ...int) (int, string) {
            total := 0
            msgx := "\n" + msg
            for _, v := range x {
              total += v
            }
            return total, msgx
          }</span></pre>
          <p>
            A função acima recebe uma quantidade indefinida de argumentos ou
            nenhum, devido ao parâmetro variádico <span>(x ...int)</span> e
            retorna um int e uma string, que foi definido aqui:
            <span>(int, string)</span>. O parâmetro será uma slice contendo os
            valores passados como argumentos. Lembrar que o parâmetro variádico
            deve ser sempre o último.
          </p>
          <p class="destac">Passando uma slice como argumento</p>
          <pre><span>func main() {
            slice := [ ]int{2, 4, 5, 6, 7, 10}
            result := sum(slice...)
            fmt.Println(result)
          }
          func sum(x ...int) int {
            total := 0
            for _, v := range x {
              total += v
            }
            return total
          }</span></pre>
        </div>
      </div>

      <div id="div20" onclick='show("div20")'>
        <h4>Utiizando "defer"(deixa para executar por último)</h4>
        <div class="oculto">
          <p>
            O "defer" é utilizado quando aquela instrução deve ser executado por
            último naquele bloco de código. Pode-se usar mais de um defer, nesse
            caso, o primeiro defer na sequência será o último e o último será o
            primeiro. Exemplo:
          </p>
          <pre><span>func main() {
            defer fmt.Println("1")
            fmt.Println("2")
            fmt.Println("3")
          }</span></pre>
          <p>No exemplo acima, será impresso "2,3,1"</p>
        </div>
      </div>

      <div id="div21" onclick='show("div21")'>
        <h4>Utilizando métodos</h4>
        <div class="oculto">
          <p>
            Os métodos só podem ser utilizados pelo type que é receptor dele.
            Uma função é composta pelas seguintes partes:
            <span>func (receiver) identifier(parameters) (returns) {code}</span>
          </p>
          <p>Então utilizamos o método assim:</p>
          <pre><span>          type people struct {
            name string
            age  int
          }          
          func (p people) greet() {
            fmt.Println("Bom dia!")
          }
          func main() {
            paulo := people{"Paulo", 40}
            paulo.greet()
          }</span></pre>
        </div>
      </div>

      <div id="div22" onclick="show('div22')">
        <h4>Utilizando Interfaces e polimorfismo</h4>
        <div class="oculto">
          <pre><span>type people struct {
            name    string
            surname string
            age     int
          }
          type dentist struct {
            people
            operations int
            wage       float64
          }
          type developer struct {
            people
            language string
            projects int
          }
          func (p dentist) greet() {
            fmt.Println("Olá dentistas!")
            fmt.Println("Meu nome é", p.name, "Bom dia!")
            fmt.Println("Eu já fiz", p.operations, "operações ao todo.")
            fmt.Println("Nosso salário gira em torno de", p.wage)
          }
          func (p developer) greet() {
            fmt.Println("Olá desenvolvedores!")
            fmt.Println("Meu nome é", p.name, "Bom dia!")
            fmt.Println("Sou especialista na linguagem", p.language)
            fmt.Println("Já fiz", p.projects, "projetos.")
          }
          type apresentation interface {
            greet()
          }
          func register(a apresentation) {
            a.greet()
          }
          func main() {
            paulo := dentist{
              people: people{
                name:    "Paulo",
                surname: "Almeida",
                age:     34,
              },
              operations: 344,
              wage:       15.346,
            }
            marcos := developer{
              people: people{
                name:    "Marcos",
                surname: "Medina",
                age:     54,
              },
              language: "golang",
              projects: 12,
            }
            marcos.greet()
            fmt.Println("")
            register(marcos)
            fmt.Println("")
            paulo.greet()
            fmt.Println("")
            register(paulo)
          }</span></pre>
        </div>
      </div>

      <div id="div23" onclick='show("div23")'>
        <h4>Função anônima</h4>
        <div class="oculto">
          <pre><span>x := 10
            func(x int) {
              fmt.Printf("x vezes 5 é: %v", x*5)
            }(x)</span></pre>
        </div>
      </div>

      <div id="div24" onclick='show("div24")'>
        <h4>Utilizando closure(função que retorna uma função)</h4>
        <div class="oculto">
          <pre><span>func main() {
            a := x()
            fmt.Println(a())
            fmt.Println(a())
            b := x()
            fmt.Println(b())
            fmt.Println(b())
          }
          func x() func() int {
            i := 0
            return func() int {
              i++
              return i
            }
          }</span></pre>
          <p>
            No exemplo acima, a função x vai retornar uma função anônima cujo
            retorno será o "i + 1". A variável "a" vai receber o retorno da
            função anônima e cada vez que "a" for executado o valor anterior vai
            ser preservado e somado mais 1, o primeiro print de "a" vai ser 1 e
            o segundo vai ser 2. Ao atribuir a função "x" a "b", o valor de "i"
            será zerado para "b" mas o valor em "a" será preservado.
          </p>
        </div>
      </div>

      <div id="div25" onclick='show("div25")'>
        <h4>Função recursiva</h4>
        <div class="oculto">
          <p>
            Funções recursivas executam elas próprias até que uma condição seja
            satisfeita. No exemplo abaixo, a função irá fatorar o número passado
            como argumento até que "x" seja igual a 1.
          </p>
          <pre><span>func main() {
            fmt.Print(" = ", factorial(4))
          }
          func factorial(x int) int {
            if x == 1 {
              fmt.Print(x)
              return x
            }
            fmt.Print(x, " * ")
            return x * factorial(x-1)
          }</span></pre>
          <p>
            Também é possível obter o mesmo resultado com loops, é mais seguro e
            recomendado.
          </p>
          <pre><span>func main() {
            fmt.Println(fact(6))
          }
          func fact(x int) int {
            result := x
            for x > 2 {
              result *= x - 1
              x--
            }
            return result
          }</span></pre>
        </div>
      </div>

      <div id="div26" onclick='show("div26")'>
        <h4>Utilizando ponteiros</h4>
        <div class="oculto">
          <p>
            Quando passamos uma variável como argumento para uma função, é
            enviado uma cópia do valor da variável. Com os ponteiros é possível
            passar o endereço da memória onde está a variável e alterar o valor
            dela.
          </p>
          <pre><span>          type people struct {
            name    string
            surname string
            age     int
          }
          func main() {
            andre := people{"Andre", "Luis", 25}
            change(&andre)
          }
          func change(x *people) {
            (*x).name = "Carlos" //forma padrão de alterar o valor
            x.surname = "Almeida" //forma excepcional de alterar o valor
          }</span></pre>
          <p>
            No exemplo acima, serão alterados os valores de name e surname da
            variável "andre" que foi passada como argumento
          </p>
        </div>
      </div>

      <div id="div27" onclick='show("div27")'>
        <h4>Converções JSON</h4>
        <div class="oculto">
          <p>De struct para JSON</p>
          <pre><span>          type People struct {
            Name    string
            Surname string
            Age     int
          }
          func main() {
            andre := People{"Andre", "Luis", 25}
            andrejson, err := json.Marshal(andre)
            if err != nil {
              fmt.Println(err)
            }
            fmt.Println(string(andrejson))
          }</span></pre>
          <p>
            Para converter um struct para JSON, primeiro devemos importar o
            package "encoding/json" e usar letras maiúsculas na declaração da
            struct e nas suas chaves. A função json.Marshal() recebe um struct
            retorna um objeto json em binário e um erro(se houver), para
            vizualisar os valores corretamente, é preciso converter para string.
          </p>
          <p>De JSON para struct</p>
          <pre><span>          type People struct {
            Name    string `json:"Name"` //Essas são tags
            Surname string `json:"Surname"`
            Age     int    `json:"Age"`
          }
          func main() {
            objson := []byte(`{"Name":"Andre","Surname":"Luis","Age":25}`)
            var andre People
            err := json.Unmarshal(objson, &andre)
            if err != nil {
              fmt.Println(err)
            }
            fmt.Println(andre)
          }</span></pre>
          <p>
            Para converter um JSON para struct, vamos atribuir a variável
            "objson", o objeto json no tipo slice de byte, depois criamos a
            variável que irá receber o struct, já com o mesmo tipo de struct,
            nesse caso "People". A função "json.Unmarshal()" irá retornar um
            erro se houver e devemos passar como argumento o objson e o ponteiro
            da variável que vai receber o struct, nesse caso "andre". As "tags"
            servem para relacionar uma chave com outra, pois no json pode vir
            uma chave com nome "surname", mas no struct a chave vai ser
            "sobrenome", nesse caso a tag "surname" deve ficar ao lado da chave
            que vai receber seu valor no struct.
          </p>
        </div>
      </div>

      <div id="div28" onclick='show("div28")'>
        <h4>Ordenar slice</h4>
        <div class="oculto">
          <p>Ordenando strings e ints</p>
          <pre><span>          import (
            "fmt"
            "sort"
          )
          func main() {
            ss := []string{"pedro", "carla", "anderson", "josé", "nonato"}
            si := []int{4, 2, 8, 5, 1, 3, 7}
            sort.Strings(ss)
            sort.Ints(si)
            fmt.Println(ss, si)
          }</span></pre>
          <p>sort personalizado</p>
          <pre><span>          type carro struct {
            nome     string
            potencia int
            consumo  int
          }
          
          type ordenarPorPotencia []carro
          
          func (x ordenarPorPotencia) Len() int           { return len(x) }
          func (x ordenarPorPotencia) Less(i, j int) bool { return x[i].potencia < x[j].potencia }
          func (x ordenarPorPotencia) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
          
          type ordenarPorConsumo []carro
          
          func (x ordenarPorConsumo) Len() int           { return len(x) }
          func (x ordenarPorConsumo) Less(i, j int) bool { return x[i].consumo > x[j].consumo }
          func (x ordenarPorConsumo) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
          
          type ordenarPorNome []carro
          
          func (x ordenarPorNome) Len() int           { return len(x) }
          func (x ordenarPorNome) Less(i, j int) bool { return x[i].nome < x[j].nome }
          func (x ordenarPorNome) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
          
          func main() {
            carros := []carro{
              carro{"fusca", 80, 30},
              carro{"chevete", 50, 25},
              carro{"porshe", 100, 20},
            }
            fmt.Println("Nome | Potência | Consumo")
            fmt.Println("Inicial\n", carros)
            sort.Sort(ordenarPorPotencia(carros))
            fmt.Println("Potência\n", carros)
            sort.Sort(ordenarPorConsumo(carros))
            fmt.Println("Do menor consumo para o maior\n", carros)
            sort.Sort(ordenarPorNome(carros))
            fmt.Println("Ordem crescente alfabética\n", carros)
          }</span></pre>
        </div>
      </div>

      <div id="div29" onclick='show("div29")'>
        <h4>Encryptando senhas</h4>
        <div class="oculto">
          <pre><span>          import ("fmt"; "golang.org/x/crypto/bcrypt")
            func main() {
              crypt, _ := bcrypt.GenerateFromPassword([]byte("senha"), 10)
              decrypt := bcrypt.CompareHashAndPassword(sb, []byte("senha"))
              if decrypt != nil {
                fmt.Println("A senha está errada!")
              } else {
                fmt.Println("A senha está correta!")
              }
            }</span></pre>
          <p>
            O número 10 é para informar o tamnho do hash. Quanto maior o número,
            maior o custo computacional para gerar.
          </p>
        </div>
      </div>

      <div id="div30" onclick='show("div30")'>
        <h4>Utilizando time.Sleep()</h4>
        <div class="oculto">
          <span>time.Sleep(2 * time.Second)</span>
          <p>
            Primeiro deve-se importar o package "time". O 2 é a quantidade de
            segundos que o progama aguardará.
          </p>
        </div>
      </div>

      <div id="div31" onclick='show("div31")'>
        <h4>Utilizando goRoutines</h4>
        <div class="oculto">
          <pre><span>          func main() {
            contador :=0
            totalDeGoroutines := 100
            var wg sync.WaitGroup
            <span class="comment">//define o número total de goRoutines</span>
            wg.Add(totalDeGoroutines)
            var mu sync.Mutex
            for i := 0; i &lt; totalDeGoroutines; i++ {
              go func ()  {
                <span class="comment">//tranca a execução para que nenhuma outra goRoutine seja executada antes que essa termine</span>
                mu.Lock()
                v := contador
                <span class="comment">//libera o processador para fazer outra coisa enquanto o programa espera</span >
                runtime.Gosched()
                v++
                contador = v
                <span class="comment">//destranca a execução, liberando para que outra goRoutine seja executada</span>
                mu.Unlock()
                <span class="comment">//informa que já concluiu essa parte da goRoutine</span>
                wg.Done()
              }()
            }
            <span class="comment">//pede para não encerrar o programa até que termine todas as goRoutines</span>
            wg.Wait()
            fmt.Println("Valor final: ", contador)
          }</span></pre>
        </div>
      </div>

      <div id="div32" onclick='show("div32")'>
        <h4>Utilizando canal</h4>
        <div class="oculto">
          <p>
            Criar um canal bidirecional. OBS: Só pode enviar valor para um canal
            se ele estiver dentro de uma "go routine"
          </p>
          <pre><span>	canal := make(chan int)
            go func() {
              canal &lt;- 42
            }()
            fmt.Println(&lt;-canal)</span></pre>
          <p>
            Utilizando canais específicos de send e receive. Cada vez que rodar
            o código "channel&lt;-" será adicionado mais um valor no canal,
          </p>
          <pre><span>func main() {
            channel := make(chan int) //cria um canal que pode ser escrito ou lido
            go loop(10, channel)
            prints(channel)
          }
          
          func loop(t int, c chan&lt;- int) { //"chan&lt;-" define que serão enviados dados para o canal(send)
            for i := 0; i &lt; t; i++ {
              c &lt;- i
            }
            close(c) //informa para o canal que não vai mais receber nada
          }
          
          func prints(c &lt;-chan int) { //"&lt;-chan" define que serão recebidos dados do canal(receive)
            for v := range c {
              fmt.Println(v)
            }
          }</span></pre>
          <p>
            Fazendo um switch case para ler 2 canais e identificar de qual canal
            é o valor. Ao entrar no select, enquanto tiver algum valor no canal,
            ele vai continuar repetindo. o "v" neste exemplo, vai receber o
            valor que está sendo recebido do canal no momento
          </p>
          <pre><span>func main() {
            a := make(chan int)
            b := make(chan int)
            x := 100
          
            go func(x int) {
              for i := 0; i &lt; x; i++ {
                a &lt;- i
              }
            }(x / 2)
            go func(x int) {
              for i := 0; i &lt; x; i++ {
                b &lt;- i
              }
            }(x / 2)
          
            for i := 0; i &lt; x; i++ {
              select {
              case v := &lt;-a:
                fmt.Println("Canal A:", v)
              case v := &lt;-b:
                fmt.Println("Canal B:", v)
              }
            }
          }</span></pre>
          <p>
            Utilizando "comma ok" para verificar se ainda tem algum valor dentro
            do canal. Ao atribuir 2 variáveis ao retorno de um canal, um valor
            será o conteúdo do canal e o outro será false ou true, se o conteúdo
            for 0 e o outro valor for false, quer dizer que esse 0 não é o
            conteúdo do canal, e sim a indicação de que o canal está vazio.
          </p>
          <pre><span>func main() {
            ch := make(chan int)

            go func() {		
              ch&lt;-42
              close(ch)		
            }()
            v, ok := &lt;-ch
            fmt.Println(v, ok)
            v, ok = &lt;-ch
            fmt.Println(v, ok)
          }</span></pre>
          <p>Utilizando coverge, ou seja, convergindo dois canais em um só.</p>
          <pre><span>func main() {
          par := make(chan int)
          impar := make(chan int)
          converge := make(chan int)

          go envia(par, impar)
          go recebe(par, impar, converge)

          for v := range converge {
            fmt.Println("O valor recebido é:", v)
          }
        }

        func envia(p, i chan int) {
          x := 50
          for n := 0; n &lt;x; n++ {
            if n % 2 == 0 {
              p &lt;- n
            } else {
              i &lt;- n
            }
          }
          close(p)
          close(i)
        }

        func recebe(p, i, c chan int) {
          var wg sync.WaitGroup
          wg.Add(1)
          go func() {
            for v := range p {
              c &lt;- v
            }
            wg.Done()
          }()
          wg.Add(1)
          go func() {
            for v := range i {
              c &lt;- v
            }
            wg.Done()
          }()
          wg.Wait()
          close(c)
        }</span></pre>
          <p>
            Exemplo de mais um canal com convergência
            <a
              href="https://github.com/vkorbes/aprendago/blob/master/c%C3%B3digo/21_canais/07/rob/main.go"
              target="_blank"
              >aqui</a
            >
          </p>
          <p>
            Exemplo de canal com divergência e convergência
            <a
              href="https://github.com/vkorbes/aprendago/tree/master/c%C3%B3digo/21_canais/08"
              target="_blank"
              >aqui</a
            >
          </p>
        </div>
      </div>
    </div>
  </body>
</html>
